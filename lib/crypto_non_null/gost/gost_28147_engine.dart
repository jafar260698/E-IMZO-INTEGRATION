
// these are the S-boxes given in Applied Cryptography 2nd Ed., p. 333
// This is default S-box!
import '../gost/cipher_parameters.dart';
import '../gost/key_parameter.dart';
import '../gost/parameters_with_sbox.dart';

const Sbox_Default = [
  0x4, 0xA, 0x9, 0x2, 0xD, 0x8, 0x0, 0xE, 0x6, 0xB, 0x1, 0xC, 0x7, 0xF, 0x5, 0x3,
  0xE, 0xB, 0x4, 0xC, 0x6, 0xD, 0xF, 0xA, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9,
  0x5, 0x8, 0x1, 0xD, 0xA, 0x3, 0x4, 0x2, 0xE, 0xF, 0xC, 0x7, 0x6, 0x0, 0x9, 0xB,
  0x7, 0xD, 0xA, 0x1, 0x0, 0x8, 0x9, 0xF, 0xE, 0x4, 0x6, 0xC, 0xB, 0x2, 0x5, 0x3,
  0x6, 0xC, 0x7, 0x1, 0x5, 0xF, 0xD, 0x8, 0x4, 0xA, 0x9, 0xE, 0x0, 0x3, 0xB, 0x2,
  0x4, 0xB, 0xA, 0x0, 0x7, 0x2, 0x1, 0xD, 0x3, 0x6, 0x8, 0x5, 0x9, 0xC, 0xF, 0xE,
  0xD, 0xB, 0x4, 0x1, 0x3, 0xF, 0x5, 0x9, 0x0, 0xA, 0xE, 0x7, 0x6, 0x8, 0x2, 0xC,
  0x1, 0xF, 0xD, 0x0, 0x5, 0x7, 0xA, 0x4, 0x9, 0x2, 0x3, 0xE, 0x6, 0xB, 0x8, 0xC
];

/*
* class content S-box parameters for encrypting
* getting from, see: http://tools.ietf.org/id/draft-popov-cryptopro-cpalgs-01.txt
*                    http://tools.ietf.org/id/draft-popov-cryptopro-cpalgs-02.txt
*/
const ESbox_Test = [
  0x4, 0x2, 0xF, 0x5, 0x9, 0x1, 0x0, 0x8, 0xE, 0x3, 0xB, 0xC, 0xD, 0x7, 0xA, 0x6,
  0xC, 0x9, 0xF, 0xE, 0x8, 0x1, 0x3, 0xA, 0x2, 0x7, 0x4, 0xD, 0x6, 0x0, 0xB, 0x5,
  0xD, 0x8, 0xE, 0xC, 0x7, 0x3, 0x9, 0xA, 0x1, 0x5, 0x2, 0x4, 0x6, 0xF, 0x0, 0xB,
  0xE, 0x9, 0xB, 0x2, 0x5, 0xF, 0x7, 0x1, 0x0, 0xD, 0xC, 0x6, 0xA, 0x4, 0x3, 0x8,
  0x3, 0xE, 0x5, 0x9, 0x6, 0x8, 0x0, 0xD, 0xA, 0xB, 0x7, 0xC, 0x2, 0x1, 0xF, 0x4,
  0x8, 0xF, 0x6, 0xB, 0x1, 0x9, 0xC, 0x5, 0xD, 0x3, 0x7, 0xA, 0x0, 0xE, 0x2, 0x4,
  0x9, 0xB, 0xC, 0x0, 0x3, 0x6, 0x7, 0x5, 0x4, 0x8, 0xE, 0xF, 0x1, 0xA, 0x2, 0xD,
  0xC, 0x6, 0x5, 0x2, 0xB, 0x0, 0x9, 0xD, 0x3, 0xE, 0x7, 0xA, 0xF, 0x4, 0x1, 0x8
];

const ESbox_A = [
  0x9, 0x6, 0x3, 0x2, 0x8, 0xB, 0x1, 0x7, 0xA, 0x4, 0xE, 0xF, 0xC, 0x0, 0xD, 0x5,
  0x3, 0x7, 0xE, 0x9, 0x8, 0xA, 0xF, 0x0, 0x5, 0x2, 0x6, 0xC, 0xB, 0x4, 0xD, 0x1,
  0xE, 0x4, 0x6, 0x2, 0xB, 0x3, 0xD, 0x8, 0xC, 0xF, 0x5, 0xA, 0x0, 0x7, 0x1, 0x9,
  0xE, 0x7, 0xA, 0xC, 0xD, 0x1, 0x3, 0x9, 0x0, 0x2, 0xB, 0x4, 0xF, 0x8, 0x5, 0x6,
  0xB, 0x5, 0x1, 0x9, 0x8, 0xD, 0xF, 0x0, 0xE, 0x4, 0x2, 0x3, 0xC, 0x7, 0xA, 0x6,
  0x3, 0xA, 0xD, 0xC, 0x1, 0x2, 0x0, 0xB, 0x7, 0x5, 0x9, 0x4, 0x8, 0xF, 0xE, 0x6,
  0x1, 0xD, 0x2, 0x9, 0x7, 0xA, 0x6, 0x0, 0x8, 0xC, 0x4, 0x5, 0xF, 0x3, 0xB, 0xE,
  0xB, 0xA, 0xF, 0x5, 0x0, 0xC, 0xE, 0x8, 0x6, 0x2, 0x3, 0x9, 0x1, 0x7, 0xD, 0x4
];

const ESbox_B = [
  0x8, 0x4, 0xB, 0x1, 0x3, 0x5, 0x0, 0x9, 0x2, 0xE, 0xA, 0xC, 0xD, 0x6, 0x7, 0xF,
  0x0, 0x1, 0x2, 0xA, 0x4, 0xD, 0x5, 0xC, 0x9, 0x7, 0x3, 0xF, 0xB, 0x8, 0x6, 0xE,
  0xE, 0xC, 0x0, 0xA, 0x9, 0x2, 0xD, 0xB, 0x7, 0x5, 0x8, 0xF, 0x3, 0x6, 0x1, 0x4,
  0x7, 0x5, 0x0, 0xD, 0xB, 0x6, 0x1, 0x2, 0x3, 0xA, 0xC, 0xF, 0x4, 0xE, 0x9, 0x8,
  0x2, 0x7, 0xC, 0xF, 0x9, 0x5, 0xA, 0xB, 0x1, 0x4, 0x0, 0xD, 0x6, 0x8, 0xE, 0x3,
  0x8, 0x3, 0x2, 0x6, 0x4, 0xD, 0xE, 0xB, 0xC, 0x1, 0x7, 0xF, 0xA, 0x0, 0x9, 0x5,
  0x5, 0x2, 0xA, 0xB, 0x9, 0x1, 0xC, 0x3, 0x7, 0x4, 0xD, 0x0, 0x6, 0xF, 0x8, 0xE,
  0x0, 0x4, 0xB, 0xE, 0x8, 0x3, 0x7, 0x1, 0xA, 0x2, 0x9, 0x6, 0xF, 0xD, 0x5, 0xC
];

const ESbox_C = [
  0x1, 0xB, 0xC, 0x2, 0x9, 0xD, 0x0, 0xF, 0x4, 0x5, 0x8, 0xE, 0xA, 0x7, 0x6, 0x3,
  0x0, 0x1, 0x7, 0xD, 0xB, 0x4, 0x5, 0x2, 0x8, 0xE, 0xF, 0xC, 0x9, 0xA, 0x6, 0x3,
  0x8, 0x2, 0x5, 0x0, 0x4, 0x9, 0xF, 0xA, 0x3, 0x7, 0xC, 0xD, 0x6, 0xE, 0x1, 0xB,
  0x3, 0x6, 0x0, 0x1, 0x5, 0xD, 0xA, 0x8, 0xB, 0x2, 0x9, 0x7, 0xE, 0xF, 0xC, 0x4,
  0x8, 0xD, 0xB, 0x0, 0x4, 0x5, 0x1, 0x2, 0x9, 0x3, 0xC, 0xE, 0x6, 0xF, 0xA, 0x7,
  0xC, 0x9, 0xB, 0x1, 0x8, 0xE, 0x2, 0x4, 0x7, 0x3, 0x6, 0x5, 0xA, 0x0, 0xF, 0xD,
  0xA, 0x9, 0x6, 0x8, 0xD, 0xE, 0x2, 0x0, 0xF, 0x3, 0x5, 0xB, 0x4, 0x1, 0xC, 0x7,
  0x7, 0x4, 0x0, 0x5, 0xA, 0x2, 0xF, 0xE, 0xC, 0x6, 0x1, 0xB, 0xD, 0x9, 0x3, 0x8
];

const ESbox_D = [
  0xF, 0xC, 0x2, 0xA, 0x6, 0x4, 0x5, 0x0, 0x7, 0x9, 0xE, 0xD, 0x1, 0xB, 0x8, 0x3,
  0xB, 0x6, 0x3, 0x4, 0xC, 0xF, 0xE, 0x2, 0x7, 0xD, 0x8, 0x0, 0x5, 0xA, 0x9, 0x1,
  0x1, 0xC, 0xB, 0x0, 0xF, 0xE, 0x6, 0x5, 0xA, 0xD, 0x4, 0x8, 0x9, 0x3, 0x7, 0x2,
  0x1, 0x5, 0xE, 0xC, 0xA, 0x7, 0x0, 0xD, 0x6, 0x2, 0xB, 0x4, 0x9, 0x3, 0xF, 0x8,
  0x0, 0xC, 0x8, 0x9, 0xD, 0x2, 0xA, 0xB, 0x7, 0x3, 0x6, 0x5, 0x4, 0xE, 0xF, 0x1,
  0x8, 0x0, 0xF, 0x3, 0x2, 0x5, 0xE, 0xB, 0x1, 0xA, 0x4, 0x7, 0xC, 0x9, 0xD, 0x6,
  0x3, 0x0, 0x6, 0xF, 0x1, 0xE, 0x9, 0x2, 0xD, 0x8, 0xC, 0x4, 0xB, 0xA, 0x5, 0x7,
  0x1, 0xA, 0x6, 0x8, 0xF, 0xB, 0x0, 0x4, 0xC, 0x3, 0x5, 0x9, 0x7, 0xD, 0x2, 0xE
];

//S-box for digest
const DSbox_Test = [
  0x4, 0xA, 0x9, 0x2, 0xD, 0x8, 0x0, 0xE, 0x6, 0xB, 0x1, 0xC, 0x7, 0xF, 0x5, 0x3,
  0xE, 0xB, 0x4, 0xC, 0x6, 0xD, 0xF, 0xA, 0x2, 0x3, 0x8, 0x1, 0x0, 0x7, 0x5, 0x9,
  0x5, 0x8, 0x1, 0xD, 0xA, 0x3, 0x4, 0x2, 0xE, 0xF, 0xC, 0x7, 0x6, 0x0, 0x9, 0xB,
  0x7, 0xD, 0xA, 0x1, 0x0, 0x8, 0x9, 0xF, 0xE, 0x4, 0x6, 0xC, 0xB, 0x2, 0x5, 0x3,
  0x6, 0xC, 0x7, 0x1, 0x5, 0xF, 0xD, 0x8, 0x4, 0xA, 0x9, 0xE, 0x0, 0x3, 0xB, 0x2,
  0x4, 0xB, 0xA, 0x0, 0x7, 0x2, 0x1, 0xD, 0x3, 0x6, 0x8, 0x5, 0x9, 0xC, 0xF, 0xE,
  0xD, 0xB, 0x4, 0x1, 0x3, 0xF, 0x5, 0x9, 0x0, 0xA, 0xE, 0x7, 0x6, 0x8, 0x2, 0xC,
  0x1, 0xF, 0xD, 0x0, 0x5, 0x7, 0xA, 0x4, 0x9, 0x2, 0x3, 0xE, 0x6, 0xB, 0x8, 0xC
];

const DSbox_A = [
  0xA, 0x4, 0x5, 0x6, 0x8, 0x1, 0x3, 0x7, 0xD, 0xC, 0xE, 0x0, 0x9, 0x2, 0xB, 0xF,
  0x5, 0xF, 0x4, 0x0, 0x2, 0xD, 0xB, 0x9, 0x1, 0x7, 0x6, 0x3, 0xC, 0xE, 0xA, 0x8,
  0x7, 0xF, 0xC, 0xE, 0x9, 0x4, 0x1, 0x0, 0x3, 0xB, 0x5, 0x2, 0x6, 0xA, 0x8, 0xD,
  0x4, 0xA, 0x7, 0xC, 0x0, 0xF, 0x2, 0x8, 0xE, 0x1, 0x6, 0x5, 0xD, 0xB, 0x9, 0x3,
  0x7, 0x6, 0x4, 0xB, 0x9, 0xC, 0x2, 0xA, 0x1, 0x8, 0x0, 0xE, 0xF, 0xD, 0x3, 0x5,
  0x7, 0x6, 0x2, 0x4, 0xD, 0x9, 0xF, 0x0, 0xA, 0x1, 0x5, 0xB, 0x8, 0xE, 0xC, 0x3,
  0xD, 0xE, 0x4, 0x1, 0x7, 0x0, 0x5, 0xA, 0x3, 0xC, 0x8, 0xF, 0x6, 0x2, 0x9, 0xB,
  0x1, 0x3, 0xA, 0x9, 0x5, 0xB, 0x4, 0xF, 0x8, 0x6, 0x7, 0xE, 0xD, 0x0, 0x2, 0xC
];

class GOST28147Engine {

  static final BLOCK_SIZE = 8;
  List<int> _workingKey = [];
  bool _forEncryption = false;

  List<int> _S = Sbox_Default;

  //
  // pre-defined sbox table
  //
  static Map<String, List<int>> sBoxes = {
    "Default": Sbox_Default,
    "E_TEST": ESbox_Test,
    "E_A": ESbox_A,
    "E_B": ESbox_B,
    "E_C": ESbox_C,
    "E_D": ESbox_D,
    "D_TEST": DSbox_Test,
    "D_A": DSbox_A,
  };

  static void addSBox(String sBoxName, List<int> sBox) {
    sBoxes[sBoxName.toUpperCase()] = sBox;
  }

  static _arraycopy(List<int> inp, int inOff, List<int> out, int outOff, int length) {
    for (int i = 0; i < length; i++) {
      if (i + inOff >= inp.length) break;
      out[i + outOff] = inp[i + inOff];
    }
  }

  void init(bool forEncryption, CipherParameters params) {
    if (params is ParametersWithSBox) {
      var param = params as ParametersWithSBox;
      //
      // Set the S-Box
      //
      var sBox = param.SBox;
      if (sBox.length != Sbox_Default.length) {
        throw new Exception("invalid S-box passed to GOST28147 init");
      }

      this._S = new List.filled(sBox.length, 0);
      GOST28147Engine._arraycopy(sBox, 0, this._S, 0, sBox.length);

      //
      // set key if there is one
      //
      if (param.Parameters != null) {
        this._workingKey = this._generateWorkingKey(forEncryption, (param.Parameters as KeyParameter).Key);
      }
    } else if (params is KeyParameter) {
      this._workingKey = this._generateWorkingKey(forEncryption, (params as KeyParameter).Key);
    } else if (params != null) {
      throw new Exception("invalid parameter passed to GOST28147 init");
    }
  }

  List<int> _generateWorkingKey(bool forEncryption, List<int> userKey) {
    this._forEncryption = forEncryption;

    if (userKey.length != 32) {
      throw new Exception("Key length invalid. Key needs to be 32 byte - 256 bit!!!");
    }

    List<int> key = List.empty(growable: true);
    for (var i = 0; i != 8; i++) {
      key.add(_bytesToint(userKey, i * 4));
    }

    return key;
  }

  //array of bytes to type int
  static int _bytesToint(List<int> inp, int inOff) {
    return ((inp[inOff + 3] << 24) & 0xff000000) + ((inp[inOff + 2] << 16) & 0xff0000) + ((inp[inOff + 1] << 8) & 0xff00) + (inp[inOff] & 0xff);
  }

  String get AlgorithmName => "GOST28147";

  int get BlockSize => GOST28147Engine.BLOCK_SIZE;


  int processBlock(List<int> inp,int inOff,List<int> out, int outOff) {
    if (this._workingKey == null) {
      throw new Exception("GOST28147 engine not initialised");
    }

    if ((inOff + GOST28147Engine.BLOCK_SIZE) > inp.length) {
    throw new Exception("input buffer too short");
    }

    if ((outOff + GOST28147Engine.BLOCK_SIZE) > out.length) {
    throw new Exception("output buffer too short");
    }

    _GOST28147Func(this._workingKey, inp, inOff, out, outOff);

    return GOST28147Engine.BLOCK_SIZE;
  }

  void reset() { }

  int _GOST28147_mainStep(int n1, int key) {
    int cm = (key + n1); // CM1
    // S-box replacing
    int om;
    om = this._S[0 + ((cm >> (0 * 4)) & 0xF)] << (0 * 4);
    om += this._S[16 + ((cm >> (1 * 4)) & 0xF)] << (1 * 4);
    om += this._S[32 + ((cm >> (2 * 4)) & 0xF)] << (2 * 4);
    om += this._S[48 + ((cm >> (3 * 4)) & 0xF)] << (3 * 4);
    om += this._S[64 + ((cm >> (4 * 4)) & 0xF)] << (4 * 4);
    om += this._S[80 + ((cm >> (5 * 4)) & 0xF)] << (5 * 4);
    om += this._S[96 + ((cm >> (6 * 4)) & 0xF)] << (6 * 4);
    om += this._S[112 + ((cm >> (7 * 4)) & 0xF)] << (7 * 4);

    return (om << 11) | ((om & 0xFFFFFFFF) >> (32 - 11)); // 11-leftshift
  }

  void _GOST28147Func(List<int> workingKey, List<int> inp, int inOff, List<int> out, int outOff) {
    int N1;
    int N2;
    int tmp;  //tmp -> for saving N1
    N1 = _bytesToint(inp, inOff);
    N2 = _bytesToint(inp, inOff + 4);

    if (this._forEncryption) {
      for (int k = 0; k < 3; k++) { // 1-24 steps
        for (int j = 0; j < 8; j++) {
          tmp = N1;
          N1 = N2 ^ this._GOST28147_mainStep(N1, workingKey[j]); // CM2
          N2 = tmp;
        }
      }
      for (int j = 7; j > 0; j--) { // 25-31 steps
        tmp = N1;
        N1 = N2 ^ this._GOST28147_mainStep(N1, workingKey[j]); // CM2
        N2 = tmp;
      }
    } else { //decrypt
      for (int j = 0; j < 8; j++) { // 1-8 steps
        tmp = N1;
        N1 = N2 ^ this._GOST28147_mainStep(N1, workingKey[j]); // CM2
        N2 = tmp;
      }
      for (int k = 0; k < 3; k++) { //9-31 steps
        for (int j = 7; j >= 0; j--) {
          if ((k == 2) && (j == 0)) {
            break; // break 32 step
          }
          tmp = N1;
          N1 = N2 ^ this._GOST28147_mainStep(N1, workingKey[j]); // CM2
          N2 = tmp;
        }
      }
    }

    N2 = N2 ^ this._GOST28147_mainStep(N1, workingKey[0]);  // 32 step (N1=N1)

    _intTobytes(N1, out, outOff);
    _intTobytes(N2, out, outOff + 4);
  }

  //int to array of bytes
  void _intTobytes(int num, List<int> out, int outOff) {
    out[outOff + 3] = ((num & 0xFFFFFFFF) >> 24) & 0xFF;
    out[outOff + 2] = ((num & 0xFFFFFFFF) >> 16) & 0xFF;
    out[outOff + 1] = ((num & 0xFFFFFFFF) >> 8) & 0xFF;
    out[outOff] = num & 0xFF;
  }

  static List<int> getSBox(String sBoxName) {
    var sBox = sBoxes[sBoxName.toUpperCase()];
    if (sBox == null) {
      throw new Exception("Unknown S-Box - possible types: \"Default\", \"E_Test\", \"E_A\", \"E_B\", \"E_C\", \"E_D\", \"D_Test\", \"D_A\".");
    }
    var copy = new List.filled(sBox.length, 0);
    _arraycopy(sBox, 0, copy, 0, copy.length);
    return copy;
  }
}